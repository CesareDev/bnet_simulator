\chapter{Simulator Design and Implementation}
\label{chap:implementation}

This chapter presents the design and implementation of the custom simulator developed as the core contribution of this thesis. The simulator enables controlled, reproducible evaluation of proximity detection protocols under various network conditions and densities. We will describe the overall architecture, key components, modeling approach, and implementation details.

\section{Motivation for a Custom Simulator}

As discussed in Section~\ref{chap:background}, while general purpose network simulators like ns-3~\cite{nsnam} and OMNeT++~\cite{omnetppOMNeTDiscrete} are powerful tools, they present challenges for focused research on specific protocol: they are often complex and need a significant amount of time to learn the funcionalities and tailor them to specific needs, given that implementing a non standart behavior becomes challenging.

On the other hand, a custom simulator for evaluating custom broadcast protocols in infrastructure free networks offers noticeable advantages: we have full control over the implementation details, we can easly modify the protocol to our needs, the codebase is much more simpler and we can introduce only the components that are necessary for our research objective.

The simulator developed for this thesis focuses specifically on MAC layer broadcast behavior in wireless ad hoc networks with mobility and dynamic node populations.

\section{Overall Architecture}

The simulator is built around a discrete event simulation paradigm, where the system state evolves through a sequence of instantaneous events occurring at specific times. The overall architecture is illustrated in the following in figure:

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{img/uml_proj.png}
\caption{UML diagram of the simulator.}
\label{fig:simulator-architecture}
\end{figure}

\subsection{Classes Diagram}

The main classes of the simulator are illustrated in the following UML diagrams:

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/uml_beacon_class.png}
\caption{UML diagram of the Beacon class.}
\label{fig:beacon-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{img/uml_buoy_class.png}
\caption{UML diagram of the Buoy class.}
\label{fig:buoy-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{img/uml_channel_class.png}
\caption{UML diagram of the Channel class.}
\label{fig:channel-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/uml_scheduler_class.png}
\caption{UML diagram of the Scheduler class.}
\label{fig:scheduler-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.3\textwidth]{img/uml_event_class.png}
\caption{UML diagram of the Event class.}
\label{fig:event-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{img/uml_simulator_class.png}
\caption{UML diagram of the Simulator class.}
\label{fig:simulator-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img/uml_config_class.png}
\caption{UML diagram of the ConfigHandler class.}
\label{fig:confighandler-class}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{img/uml_metrics_class.png}
\caption{UML diagram of the Metrics class.}
\label{fig:metrics-class}
\end{figure}

\subsection{Event Driven Design}

The simulation progresses by processing events from a priority queue ordered by simulation time. Each event has:

\begin{itemize}
    \item The simulation time at which the event occurs
    \item The category of event (scheduler check, transmission start, reception, etc.)
    \item The object responsible for handling the event (a buoy, the channel, or the simulator itself)
    \item Optional payload containing event information (e.g. beacon data)
\end{itemize}

The event queue is implemented using Python's \texttt{heapq}~\cite{pythonHeapqHeap} module, which provides efficient $\mathcal{O}(\log n)$ insertion and $\mathcal{O}(\log n)$ extraction of the minimum element. To ensure deterministic ordering when events have identical timestamps, each event is assigned a unique sequence number that serves as a secondary sort key.

\subsection{Event Types}

The simulator defines twelve distinct event types, each representing a state transition or action in the system:

\begin{enumerate}
    \item \texttt{SCHEDULER\_CHECK:} Periodic evaluation of whether a buoy should transmit a beacon
    \item \texttt{CHANNEL\_SENSE:} Check if the wireless channel is idle before transmission
    \item \texttt{DIFS\_COMPLETION:} DCF Interframe Space waiting period completes
    \item \texttt{BACKOFF\_COMPLETION:} Random backoff countdown reaches zero
    \item \texttt{TRANSMISSION\_START:} Buoy begins transmitting a beacon frame
    \item \texttt{TRANSMISSION\_END:} Beacon transmission completes
    \item \texttt{RECEPTION:} Buoy receives a beacon from another node
    \item \texttt{NEIGHBOR\_CLEANUP:} Remove stale entries from neighbor table
    \item \texttt{BUOY\_MOVEMENT:} Update position of mobile buoys
    \item \texttt{CHANNEL\_UPDATE:} Periodic channel state maintenance
    \item \texttt{BUOY\_ARRAY\_UPDATE:} Add or remove buoys to simulate dynamic population
    \item \texttt{AVG\_NEIGHBORS\_CALCULATION:} Compute average neighbor count for metrics
\end{enumerate}

This events structure separates concerns: protocol logic (scheduler checks), MAC behavior (sensing, DIFS, backoff), physical transmission (start/end), reception processing, mobility, and system-level updates.

\subsection{Modular Component Structure}

The simulator is organized into several python modules that encapsulate distinct responsibilities:

\begin{itemize}
    \item \texttt{simulator.py:} Main simulation engine, event queue management, time progression
    \item \texttt{events.py:} Event type definitions and event data structures
    \item \texttt{channel.py:} Wireless channel model, collision detection, signal propagation
    \item \texttt{buoy.py:} Node behavior, state machine, neighbor management
    \item \texttt{beacon.py:} Beacon frame structure and serialization
    \item \texttt{scheduler.py:} Beaconing protocol implementations
    \item \texttt{metrics.py:} Performance measurement and data collection
    \item \texttt{config\_handler.py:} Configuration management and parameter access
\end{itemize}

This design facilitates independent development and extension of individual components without affecting too much the rest of the system.

\section{Node Model: The Buoy Class}

The \texttt{Buoy} class represents individual network nodes (smart buoys or optionally the vessel units) and implements their behavior.

\subsection{Node State}

Each buoy maintains the following state:

\begin{itemize}
    \item Unique UUID identifier
    \item A tuple $(x, y)$ that represents the coordinates within the simulation area
    \item A flag indicating a mobile or buoy
    \item A tuple $(v_x, v_y)$ representing the velocity for mobile nodes
    \item Remaining energy percentage
    \item List of recently known nodes (neighbors) with (ID, timestamp, position)
    \item Current state of the nodes (\texttt{SLEEPING}, \texttt{RECEIVING}, \texttt{WAITING\_DIFS}, \texttt{BACKOFF})
    \item Current backoff counter and remaining time
    \item Scheduler instance, next transmission time, pending transmission flag
\end{itemize} 

% Multi hop modes
%For multi-hop modes, additional state tracks:
%\begin{itemize}
%    \item \textbf{Discovered nodes:} Nodes learned indirectly from neighbor lists (append mode)
%    \item \textbf{Forwarded beacons:} Set of beacons already forwarded to prevent duplicates (forwarded mode)
%\end{itemize}

\subsection{Transmission State Machine}

Buoy behavior follows a state machine that implements the IEEE 802.11 DCF~\cite{dcf} mechanism:

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{img/uml_buoy_state_machine.png}
\caption{UML diagram of the buoy transmission state machine.}
\label{fig:buoy-state-machine}
\end{figure}

\textbf{State transitions:}

\begin{enumerate}
    \item \texttt{RECEIVING $\to$ CHANNEL\_SENSE}: Scheduler decides to transmit and initiate channel sensing
    \item If the channel is busy, defer and retry sensing after short interval
    \item If the channel is idle $\to$ \texttt{WAITING\_DIFS}: Wait for DIFS period (50 $\mu$s)
    \item \texttt{DIFS\_COMPLETION:} Check again the channel; if still idle, enter \texttt{BACKOFF}
    \begin{enumerate}
        \item \texttt{BACKOFF:} Count down random slots $(0-15)\times \text{slot\_time}$ (20 $\mu$s)
        \item \texttt{BACKOFF\_COMPLETION:} Transmit beacon and return to \texttt{RECEIVING}
    \end{enumerate}
    \item IF the channel becomes busy during \texttt{BACKOFF}: Pause counter, return to \texttt{RECEIVING}, resume when idle
\end{enumerate}

This sequence models the CSMA/CA~\cite{networkacademyCollisionAvoidance} collision avoidance mechanism, including the behavior where backoff counters stop when the channel becomes busy and resume when idle.

\subsection{Neighbor Table Management}

Each buoy maintains a neighbor table to track recently heard nodes. Upon receiving a beacon:

\begin{enumerate}
    \item Extract sender ID, timestamp, and position
    \item Search for existing entry with matching sender ID
    \item If found, update timestamp and position
    \item If not found, add new entry to table
    \item Extract neighbor list from beacon payload for indirect discovery
\end{enumerate}

Periodically, a \texttt{NEIGHBOR\_CLEANUP} event triggers removal of stale entries:

\begin{verbatim}
neighbors = [(id, ts, pos) for (id, ts, pos) in neighbors
             if current_time - ts <= timeout]
\end{verbatim}

Entries not refreshed within the timeout period ($3\times\text{static\_interval}$) are expired. This allows the buoy to maintain an up to date view of its local neighborhood.

\subsection{Mobility Model}

Mobile buoys move according to a simple kinematic model. Every 100 ms, a \texttt{BUOY\_MOVEMENT} event updates position:
\begin{align*}
x_{t+\Delta t} &= x_t + v_x \cdot \Delta t \\
y_{t+\Delta t} &= y_t + v_y \cdot \Delta t
\end{align*}

where $(v_x, v_y)$ is the velocity vector in m/s and $\Delta t = 0.1$ s.

Since the simulated area is bounded, when a buoy reaches the edge, the corresponding velocity component is negated, causing the buoy to "bounce" back into the valid area. In this way the nodes remain within the simulation bounds and prevents, during longer simulation, nodes drifting out of range.

\section{Channel Model}

The \texttt{Channel} class models the wireless propagation medium, implementing signal propagation, range based reception, and collision detection.

\subsection{Signal Propagation}

When a buoy broadcasts a beacon, the channel determines which other buoys are within communication range and schedules \texttt{RECEPTION} events. The channel implements a distance based reception probability model calibrated from real world sea trials. For each potential receiver:

\begin{enumerate}
    \item Calculate Euclidean distance between sender and receiver:
    $$d = \sqrt{(x_r - x_s)^2 + (y_r - y_s)^2}$$
    
    \item Determine reception probability based on distance:
    \begin{align*}
    P_{\text{rx}} = \begin{cases}
    0.9 & \text{if } d \leq 70 \text{ m (high-probability zone)} \\
    0.15 & \text{if } 70 < d \leq 120 \text{ m (low-probability zone)} \\
    0 & \text{if } d > 120 \text{ m (beyond range)}
    \end{cases}
    \end{align*}
    
    \item Generate random value $r \sim U(0,1)$ and accept reception if $r < P_{\text{rx}}$
\end{enumerate}

This probabilistic model captures the field trial observation that reception is highly reliable within 70 meters, sporadic between 70-120 meters, and negligible beyond 120 meters over water.

\subsubsection{Propagation Delay}

For accepted receptions, the reception time includes propagation delay:

$$t_{\text{rx}} = t_{\text{tx\_end}} + \frac{d}{c}$$

where $c = 3 \times 10^8$ m/s is the speed of light. Though small (400 ns per 120 m), including propagation delay ensures proper temporal ordering when multiple transmissions overlap.

\subsection{Collision Detection}

The channel tracks all active transmissions in a list of tuples:
\begin{verbatim}
(beacon, start_time, end_time, 
potential_receivers, actual_receivers)
\end{verbatim}

When a new transmission begins, the channel checks for temporal and spatial overlap with existing transmissions.

\subsubsection{Collision Conditions}

A collision occurs between transmissions A and B at receiver R if:

\begin{enumerate}
    \item Transmission time intervals intersect
    $$[t_{\text{start}}^A, t_{\text{end}}^A] \cap [t_{\text{start}}^B, t_{\text{end}}^B] \neq \emptyset$$
    
    \item R is within range of both senders
    $$d(R, A) \leq R_{\text{max}} \land d(R, B) \leq R_{\text{max}}$$
\end{enumerate}

When a collision is detected, both transmissions are marked as collided, and affected receivers do not generate \texttt{RECEPTION} events.

\subsubsection{Hidden Terminal Modeling}

The collision model handles hidden terminals: senders A and B may be out of range of each other (and thus cannot detect each other's transmissions via carrier sense), yet both transmit simultaneously, causing a collision at a receiver R that is within range of both.

This is a very important aspect of broadcast reliability in ad hoc networks and must be accurately modeled for realistic evaluation.

\subsection{Ideal vs. Probabilistic Channel}

The simulator supports two channel modes:

\begin{itemize}
    \item \textbf{Ideal channel:} All transmissions within range are received unless they collide. $P_{\text{rx}} = 1$ for all $d \leq R_{\text{max}}$. Used to isolate the impact of MAC layer collisions from physical layer effects.
    
    \item \textbf{Probabilistic channel:} Uses the calibrated distance based reception probabilities. Models realistic over water propagation.
\end{itemize}

Both modes use identical collision detection. The ideal channel provides an upper bound on performance, while the probabilistic channel reflects realistic conditions.

\subsection{Carrier Sensing}

The channel implements a carrier sensing mechanism used by the buoy state machine. When a buoy checks if the channel is busy:

\begin{enumerate}
    \item Iterate through all active transmissions
    \item For each transmission, calculate wavefront radius:
    $$r_{\text{wave}} = c \cdot (t_{\text{current}} - t_{\text{start}})$$
    
    \item If the buoy is within both the wavefront radius and the high-probability detection range, the channel is sensed as busy:
    $$d(\text{buoy}, \text{sender}) \leq \min(r_{\text{wave}}, R_{\text{high}})$$
\end{enumerate}

This models the physical reality that a signal takes time to propagate through space and can only be sensed once the wavefront reaches the sensing node.

\section{Protocol Implementation}

The \texttt{BeaconScheduler} class implements the beaconing protocol logic, abstracting the decision of when to transmit.

\subsection{Static Beaconing Protocol (SBP)}

The static protocol is straightforward:

\begin{verbatim}
class BeaconScheduler:
    def should_send_static(self, current_time):
        if current_time - last_send_time >= static_interval:
            last_send_time = current_time
            return True
        return False
\end{verbatim}

Every \texttt{static\_interval} seconds (e.g., 0.25s), the scheduler returns \texttt{True}, triggering the buoy to initiate the transmission sequence.

\subsection{Adaptive Density-Aware Beaconing (ADAB)}

ADAB implements the density driven interval adaptation described in Chapter~\ref{chap:prosafe}:

\begin{verbatim}
def compute_interval(self, velocity, neighbors, current_time):
    n_neighbors = len(neighbors)
    density_score = min(1.0, n_neighbors / NEIGHBORS_THRESHOLD)
    
    f = density_score * density_score  # Quadratic mapping
    bi = BI_MIN + f * (BI_MAX - BI_MIN)
    
    jitter = random.uniform(-0.05, 0.05)
    bi_final = bi * (1 + jitter)
    
    return max(BI_MIN, min(bi_final, BI_MAX))
\end{verbatim}

At each transmission decision point:

\begin{enumerate}
    \item Count current neighbors (after expiring stale entries)
    \item Compute normalized density score $f = \min(1, N / N_{\text{thr}})$
    \item Apply quadratic mapping: $BI = BI_{\min} + f^2 \cdot (BI_{\max} - BI_{\min})$
    \item Add random jitter $\pm 5\%$
    \item Clamp to valid interval $[BI_{\min}, BI_{\max}]$
    \item Schedule next transmission at $t + BI$
\end{enumerate}

The scheduler maintains state across function calls:
\begin{itemize}
    \item \texttt{last\_send\_time:} Timestamp of previous transmission
    \item \texttt{next\_interval:} Computed interval for next transmission
\end{itemize}

\section{Metrics Collection}

The \texttt{Metrics} class tracks performance data throughout simulation execution.

\subsection{Primary Metrics}

The class maintains the following metrics throughout the duration of the simulation:

\begin{itemize}
    \item Total number of beacon transmissions initiated
    \item Sum over all transmissions of receivers in range
    \item Number of successful receptions (no collision, probabilistic success)
    \item Number of receptions lost due to temporal/spatial overlap
    \item Receptions lost due to distance based random failure
\end{itemize}

\subsection{Broadcast Packet Delivery Ratio (B-PDR)}

The key metric is computed as:

$$\text{B-PDR} = \frac{\sum_{i=1}^{N_{\text{tx}}} n_{\text{rcv},i}}{\sum_{i=1}^{N_{\text{tx}}} n_{\text{intended},i}}$$

where for each transmission $i$:
\begin{itemize}
    \item $n_{\text{intended},i}$ = number of nodes within range at transmission time
    \item $n_{\text{rcv},i}$ = number that actually received the beacon
\end{itemize}

In the class implementation the numerator is stored in the \texttt{actually\_received} variable and the denominator in the \texttt{potentially\_sent} variable.

\section{Dynamic Population Management}

To model realistic deployment scenarios where users enter and leave the system, the simulator implements stochastic node churn.

\subsection{Churn Process}

At irregular intervals (every 15-20 seconds), the simulator randomly either adds or removes buoys:

\begin{verbatim}
if random() >= 0.5 and len(active) > minimum:
    # Remove operation
    remove_count = random(1, min(max_remove, len(active) - minimum))
    buoys_to_remove = random_sample(active, remove_count)
    for buoy in buoys_to_remove:
        active.remove(buoy)
else:
    # Add operation
    add_count = random(1, min(max_add, len(inactive)))
    buoys_to_add = random_sample(inactive, add_count)
    for buoy in buoys_to_add:
        active.append(buoy)
        schedule_initial_events(buoy)
\end{verbatim}

Constraints maintain population bounds:
\begin{itemize}
    \item Minimum: $\max(3, 0.2 \times N_{\text{total}})$
    \item Maximum: $N_{\text{total}}$ (all available buoys)
    \item Remove fraction: Up to 40\% of current population
    \item Add fraction: Up to 40\% of current population
\end{itemize}

This creates a dynamic but bounded population that exercises the adaptive protocol's responsiveness to density changes.

\section{Configuration Management}

All simulation parameters are written in a YAML configuration file (\texttt{config.yaml}), loaded by the \texttt{ConfigHandler} singleton class at startup. This separates configuration decision from the actual implementation making easy to run multiple simulations with different settings.

\begin{Verbatim}[commandchars=\\\{\}]
simulation:
  duration: 600 \textcolor{darkgreen}{// Duration of the simulation in seconds}
  ideal_channel: true \textcolor{darkgreen}{// Use ideal or probabilistic channel model}
  multihop_mode: none \textcolor{darkgreen}{// none, append, forwarded}
  
network:
  bit_rate: 1000000 \textcolor{darkgreen}{// PHY rate in bps}
  communication_range_max: 120.0 \textcolor{darkgreen}{// Max comm range in meters}
  communication_range_high_prob: 70.0 \textcolor{darkgreen}{// High prob range in meters}
  delivery_prob_high: 0.9 \textcolor{darkgreen}{// Delivery probability in high prob zone}
  delivery_prob_low: 0.15 \textcolor{darkgreen}{// Delivery probability in low prob zone}
  
csma:
  difs_time: 0.000050 \textcolor{darkgreen}{// DIFS duration in seconds}
  slot_time: 0.000020 \textcolor{darkgreen}{// Slot time in seconds}
  cw: 16 \textcolor{darkgreen}{// Contention window size}
  
scheduler:
  beacon_min_interval: 0.25 \textcolor{darkgreen}{// Minimum beacon interval in seconds}
  beacon_max_interval: 5.0 \textcolor{darkgreen}{// Maximum beacon interval in seconds}
  static_interval: 1.0 \textcolor{darkgreen}{// Static beaconing interval in seconds}
  neighbor_timeout: 5.0 \textcolor{darkgreen}{// Neighbor timeout in seconds}
\end{Verbatim}

\section{Calibration with Real-World Measurements}

The simulator's channel model is calibrated using empirical measurements from sea trial.

\subsection{Field Trial Setup}

Two Raspberry Pi 4 Model B units equipped with:
\begin{itemize}
    \item AR9271-based USB Wi-Fi adapter
    \item 2 dBi omnidirectional antenna
    \item GPS module for position tracking
    \item Battery pack for autonomous operation
\end{itemize}

were deployed on open water with static beaconing at 1.0 s intervals.

\subsection{Measurement Results}

Reception success rate vs. distance:
\begin{itemize}
    \item 0-70 m: $\sim$90\% success (reliable zone)
    \item 70-120 m: $\sim$15\% success (marginal zone)
    \item >120 m: Near-zero success (beyond range)
\end{itemize}

These measurements directly parameterize the probabilistic channel model:
\begin{itemize}
    \item \texttt{communication\_range\_high\_prob = 70.0}
    \item \texttt{communication\_range\_max = 120.0}
    \item \texttt{delivery\_prob\_high = 0.9}
    \item \texttt{delivery\_prob\_low = 0.15}
\end{itemize}

This grounding in empirical data ensures that simulation results reflect realistic over water propagation characteristics.

\section{Implementation Technology}

The simulator is implemented in Python 3.10+~\cite{python} for several reasons: Python is a high-level, interpreted language with a simple syntax and a broad ecosystem of libraries that facilitate rapid development and prototyping for example for data analysis and plotting.

\section{Limitations}

The simulator makes several simplifying assumptions related moslty to physical layer modeling: altitude and three-dimensional propagation are not modeled, a static PHY rate is used, perfect timing is assumed (no clock drift~\cite{sciencedirectClockDrift}), mobility is simplified assuming a linear trajectory not considering environmental factors.

These simplifications are deliberate: they reduce complexity while preserving the essential interests of our study (MAC layer contention, collisions, density effects) that are the focus of this research.

\section{Summary}

This chapter has presented the design and implementation of the custom event-driven simulator:

\begin{itemize}
    \item Event-driven architecture with priority queue and discrete time progression
    \item Modular component structure separating concerns: nodes, channel, protocols, metrics
    \item Accurate modeling of IEEE 802.11 DCF: carrier sensing, DIFS, backoff, collisions
    \item Implementation of SBP and ADAB protocols with extensible scheduler design
    \item Metrics collection including B-PDR and collision rates
    \item Configuration management enabling reproducible experiments
    \item Discussing limitation comparing with real world issues
\end{itemize}

The simulator provides a controlled, reproducible platform for evaluating broadcast protocols under various conditions. The next chapter will present the experimental methodology and results obtained using this simulator.